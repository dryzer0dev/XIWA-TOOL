"""
Copyright (c) 2025 Dryz3R - XiwA Tool
All rights reserved.

ENGLISH:
This software is the property of Dryz3R and is protected by copyright laws.
Unauthorized copying, distribution, or modification of this software is strictly prohibited.
XiwA Tool is a comprehensive security and analysis suite developed by Dryz3R.

FRANÇAIS:
Ce logiciel est la propriété de Dryz3R et est protégé par les lois sur le droit d'auteur.
La copie, la distribution ou la modification non autorisée de ce logiciel est strictement interdite.
XiwA Tool est une suite complète de sécurité et d'analyse développée par Dryz3R.

ESPAÑOL:
Este software es propiedad de Dryz3R y está protegido por las leyes de derechos de autor.
Se prohíbe estrictamente la copia, distribución o modificación no autorizada de este software.
XiwA Tool es una suite completa de seguridad y análisis desarrollada por Dryz3R.
"""

import requests
import json
from requests.exceptions import RequestException
from urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(category=InsecureRequestWarning)
import socket
import ssl
import whois
import nmap
import os
from bs4 import BeautifulSoup
from datetime import datetime
from colorama import Fore, Style

def banner():
    print(f"""{Fore.RED}
╔══════════════════════════════════════╗
║     Website Vulnerability Scanner     ║
╚══════════════════════════════════════╝{Style.RESET_ALL}
""")

def check_headers(url):
    try:
        response = requests.head(url)
        headers = response.headers
        security_headers = {
            'Strict-Transport-Security': 'Missing HSTS header',
            'X-Frame-Options': 'Clickjacking possible',
            'X-Content-Type-Options': 'MIME-sniffing possible',
            'Content-Security-Policy': 'Missing CSP header',
            'X-XSS-Protection': 'XSS protection disabled'
        }
        
        findings = []
        for header, risk in security_headers.items():
            if header not in headers:
                findings.append(risk)
        return findings
    except:
        return ["Impossible de vérifier les headers"]

def check_ssl(domain):
    try:
        context = ssl.create_default_context()
        with socket.create_connection((domain, 443)) as sock:
            with context.wrap_socket(sock, server_hostname=domain) as ssock:
                cert = ssock.getpeercert()
                expiry = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                if expiry < datetime.now():
                    return "Certificat SSL expiré"
                return "SSL OK"
    except:
        return "Pas de SSL ou erreur SSL"

def scan_ports(domain):
    nm = nmap.PortScanner()
    nm.scan(domain, '21-23,80,443,3306,8080')
    open_ports = []
    for host in nm.all_hosts():
        for proto in nm[host].all_protocols():
            ports = nm[host][proto].keys()
            for port in ports:
                if nm[host][proto][port]['state'] == 'open':
                    open_ports.append(f"Port {port} ({nm[host][proto][port]['name']})")
    return open_ports

def check_forms(url):
    try:
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        forms = soup.find_all('form')
        
        vulnerabilities = []
        for form in forms:
            if form.get('action') and not form['action'].startswith('https'):
                vulnerabilities.append(f"Formulaire non sécurisé: {form.get('action')}")
        return vulnerabilities
    except:
        return ["Impossible d'analyser les formulaires"]

def main():
    banner()
    url = input(f"{Fore.RED}[{Fore.WHITE}*{Fore.RED}]{Fore.WHITE} Entrez l'URL du site à analyser: ")
    
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
    
    domain = url.split('/')[2]
    
    print(f"\n{Fore.RED}[{Fore.WHITE}+{Fore.RED}]{Fore.WHITE} Analyse en cours...\n")
    
    results = []
    results.append("=== RAPPORT D'ANALYSE DE SÉCURITÉ ===")
    results.append(f"Site analysé: {url}")
    results.append(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    results.append("\n=== INFORMATIONS WHOIS ===")
    
    try:
        w = whois.whois(domain)
        results.append(f"Registrar: {w.registrar}")
        results.append(f"Date de création: {w.creation_date}")
        results.append(f"Date d'expiration: {w.expiration_date}")
    except:
        results.append("Impossible d'obtenir les informations WHOIS")
    
    results.append("\n=== VULNÉRABILITÉS DES HEADERS ===")
    header_vulns = check_headers(url)
    results.extend(header_vulns)
    
    results.append("\n=== CERTIFICAT SSL ===")
    ssl_status = check_ssl(domain)
    results.append(ssl_status)
    
    results.append("\n=== PORTS OUVERTS ===")
    open_ports = scan_ports(domain)
    results.extend(open_ports)
    
    results.append("\n=== VULNÉRABILITÉS DES FORMULAIRES ===")
    form_vulns = check_forms(url)
    results.extend(form_vulns)
    
    results.append("\n=== RECOMMANDATIONS ===")
    results.append("1. Mettre à jour tous les composants du site")
    results.append("2. Implémenter HTTPS partout")
    results.append("3. Configurer correctement les headers de sécurité")
    results.append("4. Fermer les ports non nécessaires")
    results.append("5. Sécuriser tous les formulaires")
    
    with open('vulnerability_report.txt', 'w', encoding='utf-8') as f:
        f.write('\n'.join(results))
    
    print(f"{Fore.RED}[{Fore.WHITE}✓{Fore.RED}]{Fore.WHITE} Analyse terminée!")
    print(f"{Fore.RED}[{Fore.WHITE}i{Fore.RED}]{Fore.WHITE} Rapport sauvegardé dans vulnerability_report.txt")

if __name__ == "__main__":
    main()
